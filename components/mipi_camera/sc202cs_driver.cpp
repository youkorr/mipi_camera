#include "sc202cs_driver.h"
#include "esphome/core/log.h"

namespace esphome {
namespace mipi_camera {
namespace sensors {

static const char *const TAG = "sc202cs";

// ==================================================
// INFORMATIONS DU CAPTEUR
// ==================================================

const SensorInfo SC202CSDriver::INFO = {
  .name = "SC202CS",
  .manufacturer = "SmartSens",
  .pid = 0xEB52,
  .i2c_address = 0x36,
  .lane_count = 1,
  .bayer_pattern = 1,  // BGGR
  .lane_bitrate_mbps = 576,
  .width = 1280,
  .height = 720,
  .fps = 30,
  .default_exposure = 0x0800,
  .min_exposure = 0x0200,
  .max_exposure = 0x0E00,
  .default_gain_index = 20,
  .min_gain_index = 0,
  .max_gain_index = 100,
};

// ==================================================
// SÉQUENCE D'INITIALISATION
// ==================================================

const SC202CSDriver::InitRegister SC202CSDriver::INIT_SEQUENCE[] = {
  {0x0103, 0x01, 10},  // Software reset
  {0x0100, 0x00, 10},  // Standby
  
  // Configuration de base
  {0x36e9, 0x80, 0},
  {0x36ea, 0x06, 0},
  {0x36eb, 0x0a, 0},
  {0x36ec, 0x01, 0},
  {0x36ed, 0x18, 0},
  {0x36e9, 0x24, 0},
  {0x301f, 0x18, 0},
  {0x3031, 0x08, 0},
  {0x3037, 0x00, 0},
  
  // Fenêtre active (720p)
  {0x3200, 0x00, 0},
  {0x3201, 0xa0, 0},
  {0x3202, 0x00, 0},
  {0x3203, 0xf0, 0},
  {0x3204, 0x05, 0},
  {0x3205, 0xa7, 0},
  {0x3206, 0x03, 0},
  {0x3207, 0xc7, 0},
  {0x3208, 0x05, 0},
  {0x3209, 0x00, 0},
  {0x320a, 0x02, 0},
  {0x320b, 0xd0, 0},
  {0x3210, 0x00, 0},
  {0x3211, 0x04, 0},
  {0x3212, 0x00, 0},
  {0x3213, 0x04, 0},
  
  // Configuration ISP et autres réglages
  {0x3301, 0xff, 0},
  {0x3304, 0x68, 0},
  {0x3306, 0x40, 0},
  {0x3308, 0x08, 0},
  {0x3309, 0xa8, 0},
  {0x330b, 0xd0, 0},
  {0x330c, 0x18, 0},
  {0x330d, 0xff, 0},
  {0x330e, 0x20, 0},
  {0x331e, 0x59, 0},
  {0x331f, 0x99, 0},
  {0x3333, 0x10, 0},
  {0x335e, 0x06, 0},
  {0x335f, 0x08, 0},
  {0x3364, 0x1f, 0},
  {0x337c, 0x02, 0},
  {0x337d, 0x0a, 0},
  {0x338f, 0xa0, 0},
  {0x3390, 0x01, 0},
  {0x3391, 0x03, 0},
  {0x3392, 0x1f, 0},
  {0x3393, 0xff, 0},
  {0x3394, 0xff, 0},
  {0x3395, 0xff, 0},
  {0x33a2, 0x04, 0},
  {0x33ad, 0x0c, 0},
  {0x33b1, 0x20, 0},
  {0x33b3, 0x38, 0},
  {0x33f9, 0x40, 0},
  {0x33fb, 0x48, 0},
  {0x33fc, 0x0f, 0},
  {0x33fd, 0x1f, 0},
  {0x349f, 0x03, 0},
  {0x34a6, 0x03, 0},
  {0x34a7, 0x1f, 0},
  {0x34a8, 0x38, 0},
  {0x34a9, 0x30, 0},
  {0x34ab, 0xd0, 0},
  {0x34ad, 0xd8, 0},
  {0x34f8, 0x1f, 0},
  {0x34f9, 0x20, 0},
  {0x3630, 0xa0, 0},
  {0x3631, 0x92, 0},
  {0x3632, 0x64, 0},
  {0x3633, 0x43, 0},
  {0x3637, 0x49, 0},
  {0x363a, 0x85, 0},
  {0x363c, 0x0f, 0},
  {0x3650, 0x31, 0},
  {0x3670, 0x0d, 0},
  {0x3674, 0xc0, 0},
  {0x3675, 0xa0, 0},
  {0x3676, 0xa0, 0},
  {0x3677, 0x92, 0},
  {0x3678, 0x96, 0},
  {0x3679, 0x9a, 0},
  {0x367c, 0x03, 0},
  {0x367d, 0x0f, 0},
  {0x367e, 0x01, 0},
  {0x367f, 0x0f, 0},
  {0x3698, 0x83, 0},
  {0x3699, 0x86, 0},
  {0x369a, 0x8c, 0},
  {0x369b, 0x94, 0},
  {0x36a2, 0x01, 0},
  {0x36a3, 0x03, 0},
  {0x36a4, 0x07, 0},
  {0x36ae, 0x0f, 0},
  {0x36af, 0x1f, 0},
  {0x36bd, 0x22, 0},
  {0x36be, 0x22, 0},
  {0x36bf, 0x22, 0},
  {0x36d0, 0x01, 0},
  {0x370f, 0x02, 0},
  {0x3721, 0x6c, 0},
  {0x3722, 0x8d, 0},
  {0x3725, 0xc5, 0},
  {0x3727, 0x14, 0},
  {0x3728, 0x04, 0},
  {0x37b7, 0x04, 0},
  {0x37b8, 0x04, 0},
  {0x37b9, 0x06, 0},
  {0x37bd, 0x07, 0},
  {0x37be, 0x0f, 0},
  {0x3901, 0x02, 0},
  {0x3903, 0x40, 0},
  {0x3905, 0x8d, 0},
  {0x3907, 0x00, 0},
  {0x3908, 0x41, 0},
  {0x391f, 0x41, 0},
  {0x3933, 0x80, 0},
  {0x3934, 0x02, 0},
  {0x3937, 0x6f, 0},
  {0x393a, 0x01, 0},
  {0x393d, 0x01, 0},
  {0x393e, 0xc0, 0},
  {0x39dd, 0x41, 0},
  
  // Exposition et gain par défaut (seront écrasés ensuite)
  {Registers::EXPOSURE_H, 0x00, 0},
  {Registers::EXPOSURE_M, 0x08, 0},
  {Registers::EXPOSURE_L, 0x00, 0},
  {Registers::GAIN_FINE, 0xa0, 0},
  {Registers::GAIN_COARSE, 0x00, 0},
  {Registers::GAIN_ANALOG, 0x00, 0},
  
  {0x4509, 0x28, 0},
  {0x450d, 0x61, 0},
};

// ==================================================
// TABLE DE GAIN (100 valeurs)
// ==================================================

const SC202CSDriver::GainRegisters SC202CSDriver::GAIN_TABLE[] = {
  // Gain 1x - 2x (index 0-31)
  {0x80, 0x00, 0x00}, {0x84, 0x00, 0x00}, {0x88, 0x00, 0x00}, {0x8c, 0x00, 0x00},
  {0x90, 0x00, 0x00}, {0x94, 0x00, 0x00}, {0x98, 0x00, 0x00}, {0x9c, 0x00, 0x00},
  {0xa0, 0x00, 0x00}, {0xa4, 0x00, 0x00}, {0xa8, 0x00, 0x00}, {0xac, 0x00, 0x00},
  {0xb0, 0x00, 0x00}, {0xb4, 0x00, 0x00}, {0xb8, 0x00, 0x00}, {0xbc, 0x00, 0x00},
  {0xc0, 0x00, 0x00}, {0xc4, 0x00, 0x00}, {0xc8, 0x00, 0x00}, {0xcc, 0x00, 0x00},
  {0xd0, 0x00, 0x00}, {0xd4, 0x00, 0x00}, {0xd8, 0x00, 0x00}, {0xdc, 0x00, 0x00},
  {0xe0, 0x00, 0x00}, {0xe4, 0x00, 0x00}, {0xe8, 0x00, 0x00}, {0xec, 0x00, 0x00},
  {0xf0, 0x00, 0x00}, {0xf4, 0x00, 0x00}, {0xf8, 0x00, 0x00}, {0xfc, 0x00, 0x00},
  
  // Gain 2x - 4x (index 32-63)
  {0x80, 0x01, 0x00}, {0x84, 0x01, 0x00}, {0x88, 0x01, 0x00}, {0x8c, 0x01, 0x00},
  {0x90, 0x01, 0x00}, {0x94, 0x01, 0x00}, {0x98, 0x01, 0x00}, {0x9c, 0x01, 0x00},
  {0xa0, 0x01, 0x00}, {0xa4, 0x01, 0x00}, {0xa8, 0x01, 0x00}, {0xac, 0x01, 0x00},
  {0xb0, 0x01, 0x00}, {0xb4, 0x01, 0x00}, {0xb8, 0x01, 0x00}, {0xbc, 0x01, 0x00},
  {0xc0, 0x01, 0x00}, {0xc4, 0x01, 0x00}, {0xc8, 0x01, 0x00}, {0xcc, 0x01, 0x00},
  {0xd0, 0x01, 0x00}, {0xd4, 0x01, 0x00}, {0xd8, 0x01, 0x00}, {0xdc, 0x01, 0x00},
  {0xe0, 0x01, 0x00}, {0xe4, 0x01, 0x00}, {0xe8, 0x01, 0x00}, {0xec, 0x01, 0x00},
  {0xf0, 0x01, 0x00}, {0xf4, 0x01, 0x00}, {0xf8, 0x01, 0x00}, {0xfc, 0x01, 0x00},
  
  // Gain 4x - 8x (index 64-95)
  {0x80, 0x01, 0x01}, {0x84, 0x01, 0x01}, {0x88, 0x01, 0x01}, {0x8c, 0x01, 0x01},
  {0x90, 0x01, 0x01}, {0x94, 0x01, 0x01}, {0x98, 0x01, 0x01}, {0x9c, 0x01, 0x01},
  {0xa0, 0x01, 0x01}, {0xa4, 0x01, 0x01}, {0xa8, 0x01, 0x01}, {0xac, 0x01, 0x01},
  {0xb0, 0x01, 0x01}, {0xb4, 0x01, 0x01}, {0xb8, 0x01, 0x01}, {0xbc, 0x01, 0x01},
  {0xc0, 0x01, 0x01}, {0xc4, 0x01, 0x01}, {0xc8, 0x01, 0x01}, {0xcc, 0x01, 0x01},
  {0xd0, 0x01, 0x01}, {0xd4, 0x01, 0x01}, {0xd8, 0x01, 0x01}, {0xdc, 0x01, 0x01},
  {0xe0, 0x01, 0x01}, {0xe4, 0x01, 0x01}, {0xe8, 0x01, 0x01}, {0xec, 0x01, 0x01},
  {0xf0, 0x01, 0x01}, {0xf4, 0x01, 0x01}, {0xf8, 0x01, 0x01}, {0xfc, 0x01, 0x01},
  
  // Gain 8x+ (index 96-99)
  {0x80, 0x01, 0x03}, {0x90, 0x01, 0x03}, {0xa0, 0x01, 0x03}, {0xb0, 0x01, 0x03},
};

// ==================================================
// IMPLÉMENTATION
// ==================================================

SC202CSDriver::SC202CSDriver(i2c::I2CDevice* i2c) 
  : SensorDriverBase(i2c, INFO) {}

esp_err_t SC202CSDriver::init() {
  ESP_LOGI(TAG, "Initialisation SC202CS...");
  
  // Exécuter la séquence d'initialisation
  for (size_t i = 0; i < sizeof(INIT_SEQUENCE) / sizeof(InitRegister); i++) {
    const auto& reg = INIT_SEQUENCE[i];
    
    if (reg.delay_ms > 0) {
      vTaskDelay(pdMS_TO_TICKS(reg.delay_ms));
    }
    
    esp_err_t ret = write_register(reg.addr, reg.value);
    if (ret != ESP_OK) {
      ESP_LOGE(TAG, "Échec écriture reg 0x%04X", reg.addr);
      return ret;
    }
  }
  
  // Appliquer exposition et gain par défaut
  set_exposure(INFO.default_exposure);
  set_gain(INFO.default_gain_index);
  
  ESP_LOGI(TAG, "✅ SC202CS initialisé");
  ESP_LOGI(TAG, "   Exposition: 0x%04X", INFO.default_exposure);
  ESP_LOGI(TAG, "   Gain index: %d", INFO.default_gain_index);
  
  return ESP_OK;
}

esp_err_t SC202CSDriver::read_id(uint16_t* pid) {
  uint8_t pid_h, pid_l;
  
  esp_err_t ret = read_register(Registers::SENSOR_ID_H, &pid_h);
  if (ret != ESP_OK) return ret;
  
  ret = read_register(Registers::SENSOR_ID_L, &pid_l);
  if (ret != ESP_OK) return ret;
  
  *pid = (pid_h << 8) | pid_l;
  return ESP_OK;
}

esp_err_t SC202CSDriver::start_stream() {
  return write_register(Registers::STREAM_MODE, 0x01);
}

esp_err_t SC202CSDriver::stop_stream() {
  return write_register(Registers::STREAM_MODE, 0x00);
}

esp_err_t SC202CSDriver::set_exposure(uint16_t exposure) {
  uint8_t exp_h = (exposure >> 12) & 0x0F;
  uint8_t exp_m = (exposure >> 4) & 0xFF;
  uint8_t exp_l = (exposure & 0x0F) << 4;
  
  esp_err_t ret = write_register(Registers::EXPOSURE_H, exp_h);
  if (ret != ESP_OK) return ret;
  
  ret = write_register(Registers::EXPOSURE_M, exp_m);
  if (ret != ESP_OK) return ret;
  
  return write_register(Registers::EXPOSURE_L, exp_l);
}

esp_err_t SC202CSDriver::set_gain(uint8_t gain_index) {
  // Limiter à la taille de la table
  if (gain_index >= 100) gain_index = 99;
  
  const auto& gain = GAIN_TABLE[gain_index];
  
  esp_err_t ret = write_register(Registers::GAIN_FINE, gain.fine);
  if (ret != ESP_OK) return ret;
  
  ret = write_register(Registers::GAIN_COARSE, gain.coarse);
  if (ret != ESP_OK) return ret;
  
  return write_register(Registers::GAIN_ANALOG, gain.analog);
}

// ==================================================
// FLIP / MIRROR
// ==================================================

esp_err_t SC202CSDriver::set_flip(bool enable) {
  uint8_t current_value = 0;
  
  // Lire la valeur actuelle
  esp_err_t ret = read_register(Registers::FLIP_MIRROR, &current_value);
  if (ret != ESP_OK) {
    ESP_LOGW(TAG, "Échec lecture registre flip/mirror");
    return ret;
  }
  
  // Modifier le bit de flip vertical (bit 2)
  if (enable) {
    current_value |= 0x04;  // Set bit 2
  } else {
    current_value &= ~0x04; // Clear bit 2
  }
  
  ret = write_register(Registers::FLIP_MIRROR, current_value);
  if (ret == ESP_OK) {
    ESP_LOGI(TAG, "Flip vertical: %s (reg=0x%02X)", enable ? "ON" : "OFF", current_value);
  } else {
    ESP_LOGE(TAG, "Échec écriture flip");
  }
  
  return ret;
}

esp_err_t SC202CSDriver::set_mirror(bool enable) {
  uint8_t current_value = 0;
  
  // Lire la valeur actuelle
  esp_err_t ret = read_register(Registers::FLIP_MIRROR, &current_value);
  if (ret != ESP_OK) {
    ESP_LOGW(TAG, "Échec lecture registre flip/mirror");
    return ret;
  }
  
  // Modifier le bit de mirror horizontal (bit 1)
  if (enable) {
    current_value |= 0x02;  // Set bit 1
  } else {
    current_value &= ~0x02; // Clear bit 1
  }
  
  ret = write_register(Registers::FLIP_MIRROR, current_value);
  if (ret == ESP_OK) {
    ESP_LOGI(TAG, "Mirror horizontal: %s (reg=0x%02X)", enable ? "ON" : "OFF", current_value);
  } else {
    ESP_LOGE(TAG, "Échec écriture mirror");
  }
  
  return ret;
}

}  // namespace sensors
}  // namespace mipi_camera
}  // namespace esphome
